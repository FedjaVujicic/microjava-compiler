package rs.ac.bg.etf.pp1;

import java_cup.runtime.*;
import org.apache.log4j.*;

// import java.io.*;
import rs.ac.bg.etf.pp1.ast.*;


parser code {:
	
	boolean errorDetected = false;
	
	Logger log = Logger.getLogger(getClass());
   
   
    // slede redefinisani metodi za prijavu gresaka radi izmene teksta poruke
     
    public void report_fatal_error(String message, Object info) throws java.lang.Exception {
      done_parsing();
      report_error(message, info);
    }
  
    public void syntax_error(Symbol cur_token) {
        report_error("\nSyntax error", cur_token);
    }
  
    public void unrecovered_syntax_error(Symbol cur_token) throws java.lang.Exception {
        report_fatal_error("Fatal error. Parsing aborted", cur_token);
    }

    public void report_error(String message, Object info) {
    	errorDetected = true;
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" (line ").append(((Symbol)info).left).append(")");
        log.error(msg.toString());
    }
    
    public void report_info(String message, Object info) {
    	StringBuilder msg = new StringBuilder(message); 
    	if (info instanceof Symbol)
            msg.append (" (line ").append(((Symbol)info).left).append(")");
        log.info(msg.toString());
    }
    
:}

scan with {:
	Symbol s = this.getScanner().next_token();
	if (s != null && s.value != null) 
		log.info(s.toString() + " " + s.value.toString());
	return s;
:}

terminal PROGRAM, BREAK, CLASS, ELSE, CONST, IF, NEW, PRINT, READ, RETURN, VOID, EXTENDS, CONTINUE, FOR, STATIC, NAMESPACE;
terminal PLUS, MINUS, MUL, DIV, MOD, EQUAL, NOT_EQUAL, GREATER, GREATER_EQUAL, LESSER, LESSER_EQUAL, AND, OR, ASSIGN, INC, DEC;
terminal SEMICOLON, COLON, COMMA, DOT, LPAREN, RPAREN, LSQUARE, RSQUARE, LBRACE, RBRACE, WTF, REFERENCE;
terminal String IDENT;
terminal Integer NUM_CONST;
terminal Character CHAR_CONST;
terminal Boolean BOOL_CONST;

nonterminal Program, NamespaceList, NamespaceDecl, DeclList, IdentDecl, ConstDecl, Type, ConstVars, ConstVar, ConstValue, VarDecl, Vars, Var;
nonterminal MethodDeclList, MethodDecl, RetVal, FormParsOpt, FormParsList, FormPar, VarDeclList;
nonterminal StatementList, Statement, Condition, CondTerm, CondFact, Expr, Relop, Term, Addop, Factor, Mulop, ActPars, Designator, DesignatorStatement, Assignop;

nonterminal AssignExpr;

nonterminal rs.etf.pp1.symboltable.concepts.Obj ProgName;

precedence left ELSE;


Program ::= (Program) PROGRAM ProgName NamespaceList DeclList LBRACE MethodDeclList RBRACE;

ProgName ::= (ProgName) IDENT:progName;

NamespaceList ::= (Namespaces) NamespaceList NamespaceDecl
				|
				(NamespaceNone) 
				;
				
NamespaceDecl ::= (NamespaceDeclaration) NAMESPACE IDENT LBRACE DeclList LBRACE MethodDeclList RBRACE RBRACE;

DeclList ::= (Declarations) DeclList IdentDecl
			|
			(ErrorDeclaration) error SEMICOLON
			{: parser.report_error("Recovered from declaration error", null); :}
			|
			(DeclNone) 
			;

IdentDecl ::= (IdentConst) ConstDecl
			| 
			(IdentVar) VarDecl
			;
			
ConstDecl ::= (ConstDecl) CONST Type ConstVars SEMICOLON;

Type ::= (TypeNoRef) IDENT
		|
		(TypeRef) IDENT REFERENCE IDENT
		;
		
ConstVars ::= (ConstVarOne) ConstVar
			| 
			(ConstVarMul) ConstVars COMMA ConstVar
			;
		
ConstVar ::= (ConstVar0) IDENT ASSIGN ConstValue
			|
			(ErrorConstVar) error
			{: parser.report_error("Recovered from invalid variable error", null); :}
			;

ConstValue ::= (ConstValueNum) NUM_CONST
		| 
		(ConstValueChar) CHAR_CONST
		| 
		(ConstValueBool) BOOL_CONST
		;
		
VarDecl ::= (VarDecl) Type Vars SEMICOLON;

Vars ::= (VarOne) Var
		|
		(VarMul) Vars COMMA Var
		;
		
Var ::= (VarIdent) IDENT
		|
		(VarIdentArr) IDENT LSQUARE RSQUARE
		|
		(ErrorVar) error
		{: parser.report_error("Recovered from invalid variable error", null); :}
		;
		
MethodDeclList ::= (MethodDeclarations) MethodDeclList MethodDecl
				|
				(NoMethodDecl) 
				;
								
MethodDecl ::= (MethodDecl) RetVal IDENT LPAREN FormParsOpt RPAREN VarDeclList LBRACE StatementList RBRACE;

RetVal ::= (RetValType) Type
		|
		(RetValVoid) VOID
		;

FormParsOpt ::= (FormParsExist) FormParsList
			|
			(FormParsNone) 
			;
			
FormParsList ::= (FormParsOne) FormPar
			|
			(FormParsMul) FormParsList COMMA FormPar
			;
			
FormPar ::= (FormParIdent) Type IDENT
			|
			(FormParIdentArr) Type IDENT LSQUARE RSQUARE
			;

VarDeclList ::= (VarDeclarations) VarDeclList VarDecl
				|
				(VarDeclNone) 
				;

StatementList ::= (Statements) StatementList Statement
				|
				(ErrorStatement) error SEMICOLON
				{: parser.report_error("Recovered from statement error", null); :}
				|
				(StatementNone) 
				;

Statement ::= (StmtDesignator) DesignatorStatement SEMICOLON
			| 
			(StmtIf) IF LPAREN Condition RPAREN Statement
			| 
			(StmtIfElse) IF LPAREN Condition RPAREN Statement ELSE Statement
			| 
			(StmtBreak) BREAK SEMICOLON
			| 
			(StmtContinue) CONTINUE SEMICOLON
			| 
			(StmtReturn) RETURN SEMICOLON
			| 
			(StmtReturnExpr) RETURN Expr SEMICOLON
			| 
			(StmtRead) READ LPAREN Designator RPAREN SEMICOLON
			| 
			(StmtPrintExpr) PRINT LPAREN Expr RPAREN SEMICOLON
			| 
			(StmtPrintExprNum) PRINT LPAREN Expr COMMA NUM_CONST RPAREN SEMICOLON
			| 
			(StmtList) LBRACE StatementList RBRACE
			;				

Condition ::= (ConditionTerm) CondTerm
			| 
			(ConditionOrTerm) Condition OR CondTerm
			;
			
CondTerm ::= (CondTermFact) CondFact
			| 
			(CondTermAndFact) CondTerm AND CondFact
			;

CondFact ::= (CondFactExpr) Expr
			| 
			(CondFactRelExpr) Expr Relop Expr
			;
			
Expr ::= (ExprTerm) Term
		| 
		(ExprMinusTerm) MINUS Term
		| 
		(ExprAddTerm) Expr Addop Term
		; 

Term ::= (TermFactor) Factor
		| 
		(TermMulFactor) Term Mulop Factor
		;
		
Factor ::= (FactorDesignator) Designator
		| 
		(FactorDesignatorParen) Designator LPAREN RPAREN
		| 
		(FactorDesignatorActPars) Designator LPAREN ActPars RPAREN
		| 
		(FactorNum) NUM_CONST
		| 
		(FactorChar) CHAR_CONST
		| 
		(FactorBool) BOOL_CONST
		| 
		(FactorNewExpr) NEW Type LSQUARE Expr RSQUARE
		| 
		(FactorNew) NEW Type LPAREN RPAREN
		| 
		(FactorNewActPars) NEW Type LPAREN ActPars RPAREN
		| 
		(FactorExpr) LPAREN Expr RPAREN
		;	
		
Mulop ::= (OpMul) MUL
		| 
		(OpDiv) DIV
		| 
		(OpMod) MOD
		;
		
Designator ::= (DesignatorIdent) IDENT
			| 
			(DesignatorIdentRef) IDENT REFERENCE IDENT
			| 
			(DesignatorDotIdent) Designator DOT IDENT
			| 
			(DesignatorIndex) Designator LSQUARE Expr RSQUARE
			;

ActPars ::= (ActParsOneExpr) Expr
			| 
			(ActParsMulExpr) ActPars COMMA Expr
			;

Addop ::= (OpAdd) PLUS
		| 
		(OpSub) MINUS
		;

Relop ::= (OpEqual) EQUAL
		| 
		(OpNotEqual) NOT_EQUAL
		| 
		(OpGreater) GREATER
		| 
		(OpGreaterEqual) GREATER_EQUAL
		| 
		(OpLesser) LESSER
		| 
		(OpLesserEqual) LESSER_EQUAL
		;
		
DesignatorStatement ::= (Assignment) Designator Assignop AssignExpr
						|
						(FuncCallNoArg) Designator LPAREN RPAREN
						| 
						(FuncCallArg) Designator LPAREN ActPars RPAREN
						| 
						(Increment) Designator INC
						| 
						(Decrement) Designator DEC
						;

Assignop ::= (Assignop) ASSIGN;

AssignExpr ::= (AssignExpr0) Expr
			|
			(ErrorAssign) error			
			{: parser.report_error("Recovered from assignment error", null); :}
			;
